use iced::{
    Application, Color, Command, Element, Length, Point, Rectangle, Theme,
    mouse, widget::canvas::{self, Canvas, Frame, Path, Stroke},
};

#[derive(Debug, Clone, Copy)]
pub enum Message {
    MousePressed(Point),
    MouseReleased,
    MouseMoved(Point),
}

pub struct RectangleSelector {
    selecting: bool,
    start: Option<Point>,
    end: Option<Point>,
}

impl RectangleSelector {
    pub fn new() -> Self {
        Self {
            selecting: false,
            start: None,
            end: None,
        }
    }
}

impl Application for RectangleSelector {
    type Message = Message;
    type Executor = iced::executor::Default;
    type Theme = Theme;
    type Flags = ();

    fn new(_flags: Self::Flags) -> (Self, Command<Self::Message>) {
        (Self::new(), Command::none())
    }

    fn title(&self) -> String {
        String::from("Rectangle Selector")
    }

    fn update(&mut self, message: Message) -> Command<Message> {
        match message {
            Message::MousePressed(position) => {
                self.start = Some(position);
                self.end = None;
                self.selecting = true;
            }
            Message::MouseReleased => {
                self.selecting = false;
            }
            Message::MouseMoved(position) => {
                if self.selecting {
                    self.end = Some(position);
                }
            }
        }

        Command::none()
    }

    fn view(&self) -> Element<Message> {
        Canvas::new(self)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn theme(&self) -> Theme {
        Theme::Dark
    }
}

impl<Message> canvas::Program<Message> for RectangleSelector {
    type Message = Message;

    fn update(&self, event: canvas::Event, bounds: Rectangle, _cursor: canvas::Cursor) -> Option<Message> {
        match event {
            canvas::Event::Mouse(mouse::Event::ButtonPressed(mouse::Button::Left)) => {
                Some(Message::MousePressed(Point::new(bounds.x, bounds.y)))
            }
            canvas::Event::Mouse(mouse::Event::ButtonReleased(mouse::Button::Left)) => {
                Some(Message::MouseReleased)
            }
            canvas::Event::Mouse(mouse::Event::CursorMoved { position }) => {
                Some(Message::MouseMoved(position))
            }
            _ => None,
        }
    }

    fn draw(&self, bounds: Rectangle, _cursor: canvas::Cursor) -> Vec<canvas::Geometry> {
        let mut frame = Frame::new(bounds.size());

        if let (Some(start), Some(end)) = (self.start, self.end) {
            let rect_path = Path::rectangle(
                Point::new(start.x.min(end.x), start.y.min(end.y)),
                iced::Size::new((start.x - end.x).abs(), (start.y - end.y).abs()),
            );

            frame.stroke(
                &rect_path,
                Stroke {
                    width: 2.0,
                    color: Color::from_rgb(0.0, 1.0, 0.0),
                    ..Stroke::default()
                },
            );
        }

        vec![frame.into_geometry()]
    }
}
